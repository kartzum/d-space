<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<div style="font-size:10px">
    <!-- S 1 -->
    <div>
        <div>S1.</div>
        <table cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
                <td>
                    <div>Maximum consecutive oneâ€™s (or zeros) in a binary array.</div>
                </td>
                <td>
                    <div>Check whether two strings are anagram of each other.</div>
                </td>
                <td>
                    <div>Print all combinations of balanced parentheses. TC: O(4^n/sqrt(n)), SC: O(4^n/sqrt(n)).</div>
                </td>
                <td>
                    <div>Max Consecutive Ones III.</div>
                </td>
            </tr>
            <tr>
                <td>
                    <pre>
                        <code>
static int getMaxLength(int arr[]) {
    int count = 0;
    int result = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == 0) {
            count = 0;
        } else {
            count += 1;
            result = Math.max(result, count);
        }
    }
    return result;
}
                        </code>
                    </pre>
                </td>
                <td>
                    <pre>
                        <code>
static boolean areAnagram(char str1[], char str2[]) {
    if (str1.length != str2.length) {
        return false;
    }
    int m = 256;
    int[] count = new int[m];
    for (int i = 0; i < str1.length; i++) {
        count[str1[i]]++;
        count[str2[i]]--;
    }
    for (int i = 0; i < str1.length; i++) {
        if (count[i] != 0) {
            return false;
        }
    }
    return true;
}
                        </code>
                    </pre>
                </td>
                <td>
                    <pre>
                        <code>
// ()()
// (())

// ()()()
// ()(())
// (())()
// (()())
// ((()))

static List(String) generateParenthesis(int n) {
    List(String) ans = new ArrayList();
    backtrack(ans, "", 0, 0, n);
    return ans;
}

static void backtrack(List(String) ans, String cur, int open, int close, int max){
    if (cur.length() == max * 2) {
        ans.add(cur);
        return;
    }
    if (open < max)
        backtrack(ans, cur+"(", open+1, close, max);
    if (close < open)
        backtrack(ans, cur+")", open, close+1, max);
}
                        </code>
                    </pre>
                </td>
                <td>
                    <pre>
                        <code>
static int longestOnes(int[] A, int K) {
    int left = 0;
    int right = 0;
    for (right = 0; right < A.length; right++) {
        if (A[right] == 0) {
            K--;
        }
        if (K < 0) {
            if (A[left] == 0) {
                K++;
            }
            left++;
        }
    }
    return right - left;
}
                        </code>
                    </pre>
                </td>
            </tr>
        </table>
    </div>
    <!-- S 1. End.-->

    <!-- Linked List 1 -->
    <div>
        <div>Linked List 1.</div>
        <table cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
                <td>
                    <div>Reverse Linked List. TC: O(n), SC: O(1).</div>
                </td>
            </tr>
            <tr>
                <td>
                    <pre>
                        <code>
static ListNode reverseList(ListNode head) {
    ListNode current = head;
    ListNode prev = null;
    while (current != null) {
        ListNode temp = current.next;
        current.next = prev;
        prev = current;
        current = temp;
    }
    return prev;
}
                        </code>
                    </pre>
                </td>
            </tr>
        </table>
    </div>
    <!-- Linked List. End.-->

    <!-- S 2 -->
    <div>
        <div>S 2.</div>
        <table cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
                <td>
                    <div>Move Zeroes.</div>
                </td>
                <td>
                    <div>Two Sum. TC: O(n), SC: O(n).</div>
                </td>
                <td>
                    <div>Topological Sorting.</div>
                </td>
                <td>
                    <div>Is Palindrome.</div>
                </td>
            </tr>
            <tr>
                <td>
                    <pre>
                        <code>
static void moveZeroes(int[] nums) {
    if (nums == null || nums.length == 0) {
        return;
    }
    int k = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            int temp = nums[k];
            nums[k] = nums[i];
            nums[i] = temp;
            k++;
        }
    }
}
                        </code>
                    </pre>
                </td>
                <td>
                    <pre>
                        <code>
static int[] twoSum(int[] nums, int target) {
    Map<(Integer, Integer) map = new HashMap();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[]{map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
                        </code>
                    </pre>
                </td>
                <td>
                    <pre>
                        <code>
static Stack(Integer) topologicalSort(Graph graph) {
    Stack(Integer) stack = new Stack<>();
    boolean[] visited = new boolean[graph.v];

    for (int i = 0; i < graph.v; i++) {
        if (!visited[i]) {
            topologicalSortUtil(graph, i, visited, stack);
        }
    }

    return stack;
}

static void topologicalSortUtil(Graph graph, int v, boolean[] visited, Stack(Integer) stack) {
    visited[v] = true;
    for (int i : graph.adj.get(v)) {
        if (!visited[i])
            topologicalSortUtil(graph, i, visited, stack);
    }
    stack.push(v);
}
static class Graph {
        private int v;
        private LinkedList(LinkedList(Integer)) adj;

        Graph(int v) {
            this.v = v;
            adj = new LinkedList()();
            for (int i = 0; i < v; ++i)
                adj.add(new LinkedList()());
        }

        void addEdge(int v, int w) {
            adj.get(v).add(w);
        }
    }
                        </code>
                    </pre>
                </td>
                <td>
                    <pre>
                        <code>
static boolean isPalindrome(String x) {
    int l = 0;
    int r = x.length() - 1;
    while (l < r) {
        if (!Character.isLetterOrDigit(x.charAt(l))) {
            l++;
            continue;
        }
        if (!Character.isLetterOrDigit(x.charAt(r))) {
            r--;
            continue;
        }
        if (Character.toLowerCase(x.charAt(l)) != Character.toLowerCase(x.charAt(r))) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}
                        </code>
                    </pre>
                </td>
            </tr>
        </table>
    </div>
    <!-- S 2. End.-->

    <!-- S 3-->
    <div>
        <div>Tree.</div>
        <table cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
                <td>
                    <div>Evaluate Reverse Polish Notation.</div>
                </td>
            </tr>
            <tr>
                <td>
                    <pre>
                        <code>
static int evalRPN(String[] tokens) {
    Stack(Integer) stack = new Stack();
    for (String token : tokens) {
        if (!"+-*/".contains(token)) {
            int v = Integer.parseInt(token);
            stack.push(v);
            continue;
        }
        int n2 = stack.pop();
        int n1 = stack.pop();
        int r = 0;
        switch (token) {
            case "+":
                r = n1 + n2;
                break;
            case "-":
                r = n1 - n2;
                break;
            case "*":
                r = n1 * n2;
                break;
            case "/":
                r = n1 / n2;
                break;
        }
        stack.push(r);
    }
    return stack.pop();
}
                        </code>
                    </pre>
                </td>
            </tr>
        </table>
    </div>
    <!-- S 3. End. -->

    <!-- Template
    <div>
        <div>Tree.</div>
        <table cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
                <td></td>
            </tr>
        </table>
    </div>
    -->
</div>
</body>
</html>