<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<table cellspacing="0" cellpadding="0" width="100%" height="100%" border="0">
    <!-- Binary Tree.-->
    <tr>
        <td>
            <div>Binary Tree</div>
        </td>
    </tr>
    <tr>
        <td>
            <!-- Binary Tree. Traverse A Tree.-->
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>
                            <pre>
                                <code>
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }
                                </code>
                            </pre>
                        </div>
                        <div>
                <pre>
                    <code>
                        1
                       / \
                      2   3
                    /  \
                   4    5
    Depth First Traversals:
    Inorder (Left, Root, Right) : 4 2 5 1 3
    Preorder (Root, Left, Right) : 1 2 4 5 3
    Postorder (Left, Right, Root) : 4 5 2 3 1
                    </code>
                </pre>
                        </div>
                        <div>
                            <a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">Tree Traversals (Inorder, Preorder and Postorder)</a>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. InOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class InOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        run(node.left);
        System.out.print(node.val);
        run(node.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. PreOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class PreOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        System.out.print(node.val);
        run(node.left);
        run(node.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. PostOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class PostOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        run(node.left);
        run(node.right);
        System.out.print(node.val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. LevelOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class LevelOrder {
    List[List[Integer]] levelOrder(TreeNode root) {
        List[List[Integer]] list = new ArrayList[]();
        return addlevel(root, 0, list);
    }

    private List[List[Integer]] addlevel(
    TreeNode root, int level, List[List[Integer]] list) {
        if (root == null) return list;
        if (list.size() == level) {
            list.add(new ArrayList[]());
        }
        list.get(level).add(root.val);
        addlevel(root.left, level + 1, list);
        addlevel(root.right, level + 1, list);
        return list;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
            <!-- Binary Tree. Traverse A Tree. Finish.-->
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Maximum Depth</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Symmetric</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isMirror(root.left, root.right);
    }

    boolean isMirror(TreeNode l, TreeNode r) {
        if (l == null && r == null) return true;
        if (l == null || r == null) return false;
        return (l.val == r.val) && isMirror(l.right, r.left) && isMirror(l.left, r.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Path Sum</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        return calc(root, sum);
    }

    boolean calc(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.val == sum && root.left == null && root.right == null) {
            return true;
        }
        return calc(root.left, sum - root.val) || calc(root.right, sum - root.val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Serialize and Deserialize</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) return "#";
        return root.val + "," + serialize(root.left) + "," + serialize(root.right);
    }

    public TreeNode deserialize(String data) {
        Queue[String] queue = new LinkedList[](Arrays.asList(data.split(",")));
        return helper(queue);
    }

    private TreeNode helper(Queue[String] queue) {
        String s = queue.poll();
        if (s.equals("#")) return null;
        TreeNode root = new TreeNode(Integer.valueOf(s));
        root.left = helper(queue);
        root.right = helper(queue);
        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Construct Binary Tree from Inorder and Postorder Traversal</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    int p;
    Map[Integer, Integer] map = new HashMap[]();
    public TreeNode buildTree(int[] in, int[] post) {
        if(in == null || in.length == 0) return null;
        for(int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        p = post.length-1;
        return build(in, post, 0, post.length-1);
    }

    TreeNode build(int[] in, int[] post, int start, int end) {
        if(end < start) {
            p++;
            return null;
        }
        int rIdx = map.get(post[p]);
        TreeNode root = new TreeNode(post[p]);
        if(start == end) return root;
        p--;
        root.right = build(in, post, rIdx+1, end);
        p--;
        root.left = build(in, post, start, rIdx-1);
        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Construct Binary Tree from Preorder and Inorder Traversal</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
         int N = preorder.length;
        if(N==0) return null;
        TreeNode root= new TreeNode(preorder[0]);
        if(N==1) return root;

        int L = 0;
        for(int i=0;i< N;++i){
            if(inorder[i]==preorder[0])
                L = i;
        }
        root.left = buildTree(Arrays.copyOfRange(preorder, 1, L+1),
                                         Arrays.copyOfRange(inorder, 0, L));
        root.right = buildTree(Arrays.copyOfRange(preorder, L+1, N), Arrays.copyOfRange(inorder, L+1, N));
        return root;

    }

}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Validate Binary Search Tree</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        if (node == null) return true;

        int val = node.val;
        if (lower != null && val <= lower) return false;
        if (upper != null && val >= upper) return false;

        if (!helper(node.right, val, upper)) return false;
        if (!helper(node.left, lower, val)) return false;
        return true;
    }

    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. BSTIterator</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class BSTIterator {

    ArrayList[Integer] nodesSorted;
    int index;

    public BSTIterator(TreeNode root) {

        // Array containing all the nodes in the sorted order
        this.nodesSorted = new ArrayList[Integer]();

        // Pointer to the next smallest element in the BST
        this.index = -1;

        // Call to flatten the input binary search tree
        this._inorder(root);
    }

    private void _inorder(TreeNode root) {

        if (root == null) {
            return;
        }

        this._inorder(root.left);
        this.nodesSorted.add(root.val);
        this._inorder(root.right);
    }

    /**
     * @return the next smallest number
     */
    public int next() {
        return this.nodesSorted.get(++this.index);
    }

    /**
     * @return whether we have a next smallest number
     */
    public boolean hasNext() {
        return this.index + 1 < this.nodesSorted.size();
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Search in a Binary Search Tree</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null) return null;
        if(root.val == val)
            return root;
        if(val < root.val)
            return searchBST(root.left, val);
        else
            return searchBST(root.right, val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Insert into a Binary Search Tree</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            root = new TreeNode(val);
            return root;
        }

        if (root.left == null && root.right == null) {
            if (root.val <= val)
                root.right = new TreeNode(val);
            else
                root.left = new TreeNode(val);

            return root;
        }

        if (root.val <= val)
            root.right = insertIntoBST(root.right, val);

        else
            root.left = insertIntoBST(root.left, val);

        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. </div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null)
            return root;

        if (key < root.val)
            root.left = deleteNode(root.left, key);

        else if (key > root.val)
            root.right = deleteNode(root.right, key);

        else {
            if (root.left == null)
                return root.right;

            else if (root.right == null)
                return root.left;

            root.val = minValue(root.right);
            root.right = deleteNode(root.right, root.val);
        }

        return root;
    }

    private int minValue(TreeNode root) {
        int minv = root.val;

        while (root.left != null) {
            minv = root.left.val;
            root = root.left;
        }

        return minv;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <!-- Binary Tree. Finish.-->
    <!-- Breadth-first Search & Depth-First Search.-->
    <tr>
        <td>
            <div>Breadth-first Search & Depth-First Search</div>
        </td>
    <tr>
        <td>
            <!-- Binary Tree. Traverse A Tree.-->
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>bfs</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
static int bfs(Node root, Node target) {
    final LinkedList[Node] queue = new LinkedList[]();
    queue.add(root);
    int step = 0;
    while (!queue.isEmpty()) {
        step = step + 1;
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            final Node current = queue.remove();
            if (target.data == current.data) return step;
            for (Node next : current.getNodes()) {
                queue.add(next);
            }
        }
    }
    return -1;
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>dfs</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
static void dfs(final Node node) {
        final Stack[Node] stack = new Stack<>();
        final List[Node] visited = new ArrayList<>();
        stack.add(node);
        visited.add(node);
        while (!stack.isEmpty()) {
            final Node element = stack.pop();

            System.out.println(element.data);

            final List[Node] elements = element.getNodes();
            for (int i = 0; i < elements.size(); i++) {
                final Node elementI = elements.get(i);
                if (!visited.contains(elementI)) {
                    stack.add(elementI);
                    visited.add(elementI);
                }
            }
        }
    }
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <!-- Breadth-first Search & Depth-First Search. Finish.-->
    <!-- Sorts.-->
    <tr>
        <td>
            <div>Sorts</div>
        </td>
    <tr>
    <tr>
        <td>
            <!-- Binary Tree. Traverse A Tree.-->
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Quick</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
public static void quick(int[] a, int low, int high) {
    if (low >= high) {
        return;
    }
    int m = low + (high - low) / 2;
    int v = a[m];
    int i = low;
    int j = high;
    while (i <= j) {
        while (a[i] < v) {
            i++;
        }
        while (a[j] > v) {
            j--;
        }
        if (i <= j) {
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
            i++;
            j--;
        }
    }
    if (low < j) {
        quick(a, low, j);
    }
    if (high > i) {
        quick(a, i, high);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Selection</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
static void sort(int[] items) {
    for (int i = 0; i < items.length; i++) {
        int m = i;
        for (int j = i + 1; j < items.length; j++) {
            if (items[j] < items[m]) {
                m = j;
            }
        }
        int t = items[i];
        items[i] = items[m];
        items[m] = t;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Insertion</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
static void sort(int[] items) {
    for (int i = 1; i < items.length; i++) {
        for (int j = i; j > 0 && items[j] < items[j - 1]; j--) {
            int t = items[j];
            items[j] = items[j - 1];
            items[j - 1] = t;
        }
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Merge</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
public static int[] mergeSort(int[] a) {
    if (a.length <= 1) {
        return a;
    }
    int pivot = a.length / 2;
    int[] left = mergeSort(Arrays.copyOfRange(a, 0, pivot));
    int[] right = mergeSort(Arrays.copyOfRange(a, pivot, a.length));
    return merge(left, right);
}
private static int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    int leftCur = 0;
    int rightCur = 0;
    int resultCur = 0;
    while (leftCur < left.length && rightCur < right.length) {
        if (left[leftCur] < right[rightCur]) {
            result[resultCur++] = left[leftCur++];
        } else {
            result[resultCur++] = right[rightCur++];
        }
    }
    while (leftCur < left.length) {
        result[resultCur++] = left[leftCur++];
    }
    while (rightCur < right.length) {
        result[resultCur++] = right[rightCur++];
    }
    return result;
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <!-- Sorts. Finish.-->
    <!-- Linked List.-->
    <tr>
        <td>
            <div>Linked List</div>
        </td>
    <tr>
    <tr>
        <td>
            <!-- Add Two Numbers.-->
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Add Two Numbers</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
static class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode r = new ListNode(0);
        ListNode n1 = l1;
        ListNode m1 = l2;
        ListNode current = r;
        int carry = 0;
        while (n1 != null || m1 != null) {
            int x = n1 != null ? n1.val : 0;
            int y = m1 != null ? m1.val : 0;
            int s = carry + x + y;
            carry = s / 10;
            current.next = new ListNode(s % 10);
            current = current.next;
            //System.out.println("x = " + x + ", y = " + y + ", carry = " + carry + ", s = " + s);
            if (n1 != null) {
                n1 = n1.next;
            }
            if (m1 != null) {
                m1 = m1.next;
            }
        }
        if (carry > 0) {
            current.next = new ListNode(carry);
        }
        return r.next;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Reverse Linked List</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        while (current != null) {
            ListNode next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Linked List Cycle</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        System.out.println("slow = " + slow.val + ", fast = " + fast.val);
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
            System.out.println("slow = " + slow.val + ", fast = " + fast.val);
        }
        return true;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <!-- Linked List. Finish.-->
</table>
</body>
</html>