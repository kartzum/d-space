<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<table cellspacing="0" cellpadding="0" width="100%" height="100%" border="0">
    <!-- Binary Tree.-->
    <tr>
        <td>
            <div>Binary Tree</div>
        </td>
    </tr>
    <tr>
        <td>
            <!-- Binary Tree. Traverse A Tree.-->
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>
                            <pre>
                                <code>
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }
                                </code>
                            </pre>
                        </div>
                        <div>
                <pre>
                    <code>
                        1
                       / \
                      2   3
                    /  \
                   4    5
    Depth First Traversals:
    Inorder (Left, Root, Right) : 4 2 5 1 3
    Preorder (Root, Left, Right) : 1 2 4 5 3
    Postorder (Left, Right, Root) : 4 5 2 3 1
                    </code>
                </pre>
                        </div>
                        <div>
                            <a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">Tree Traversals (Inorder, Preorder and Postorder)</a>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. InOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class InOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        run(node.left);
        System.out.print(node.val);
        run(node.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. PreOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class PreOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        System.out.print(node.val);
        run(node.left);
        run(node.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. PostOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class PostOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        run(node.left);
        run(node.right);
        System.out.print(node.val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. LevelOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class LevelOrder {
    List[List[Integer]] levelOrder(TreeNode root) {
        List[List[Integer]] list = new ArrayList[]();
        return addlevel(root, 0, list);
    }

    private List[List[Integer]] addlevel(
    TreeNode root, int level, List[List[Integer]] list) {
        if (root == null) return list;
        if (list.size() == level) {
            list.add(new ArrayList[]());
        }
        list.get(level).add(root.val);
        addlevel(root.left, level + 1, list);
        addlevel(root.right, level + 1, list);
        return list;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
            <!-- Binary Tree. Traverse A Tree. Finish.-->
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Maximum Depth</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Symmetric</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isMirror(root.left, root.right);
    }

    boolean isMirror(TreeNode l, TreeNode r) {
        if (l == null && r == null) return true;
        if (l == null || r == null) return false;
        return (l.val == r.val) && isMirror(l.right, r.left) && isMirror(l.left, r.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Path Sum</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        return calc(root, sum);
    }

    boolean calc(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.val == sum && root.left == null && root.right == null) {
            return true;
        }
        return calc(root.left, sum - root.val) || calc(root.right, sum - root.val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Serialize and Deserialize</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) return "#";
        return root.val + "," + serialize(root.left) + "," + serialize(root.right);
    }

    public TreeNode deserialize(String data) {
        Queue[String] queue = new LinkedList[](Arrays.asList(data.split(",")));
        return helper(queue);
    }

    private TreeNode helper(Queue[String] queue) {
        String s = queue.poll();
        if (s.equals("#")) return null;
        TreeNode root = new TreeNode(Integer.valueOf(s));
        root.left = helper(queue);
        root.right = helper(queue);
        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Construct Binary Tree from Inorder and Postorder Traversal</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    int p;
    Map[Integer, Integer] map = new HashMap[]();
    public TreeNode buildTree(int[] in, int[] post) {
        if(in == null || in.length == 0) return null;
        for(int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        p = post.length-1;
        return build(in, post, 0, post.length-1);
    }

    TreeNode build(int[] in, int[] post, int start, int end) {
        if(end < start) {
            p++;
            return null;
        }
        int rIdx = map.get(post[p]);
        TreeNode root = new TreeNode(post[p]);
        if(start == end) return root;
        p--;
        root.right = build(in, post, rIdx+1, end);
        p--;
        root.left = build(in, post, start, rIdx-1);
        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Construct Binary Tree from Preorder and Inorder Traversal</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
         int N = preorder.length;
        if(N==0) return null;
        TreeNode root= new TreeNode(preorder[0]);
        if(N==1) return root;

        int L = 0;
        for(int i=0;i< N;++i){
            if(inorder[i]==preorder[0])
                L = i;
        }
        root.left = buildTree(Arrays.copyOfRange(preorder, 1, L+1),
                                         Arrays.copyOfRange(inorder, 0, L));
        root.right = buildTree(Arrays.copyOfRange(preorder, L+1, N), Arrays.copyOfRange(inorder, L+1, N));
        return root;

    }

}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Validate Binary Search Tree</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        if (node == null) return true;

        int val = node.val;
        if (lower != null && val <= lower) return false;
        if (upper != null && val >= upper) return false;

        if (!helper(node.right, val, upper)) return false;
        if (!helper(node.left, lower, val)) return false;
        return true;
    }

    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <!-- Binary Tree. Finish.-->
</table>
</body>
</html>