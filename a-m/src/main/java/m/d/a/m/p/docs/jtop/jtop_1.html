<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<table cellspacing="0" cellpadding="0" width="100%" height="100%" border="0">
    <!-- Binary Tree.-->
    <tr>
        <td>
            <div>Binary Tree</div>
        </td>
    </tr>
    <tr>
        <td>
            <!-- Binary Tree. Traverse A Tree.-->
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>
                            <pre>
                                <code>
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }
                                </code>
                            </pre>
                        </div>
                        <div>
                <pre>
                    <code>
                        1
                       / \
                      2   3
                    /  \
                   4    5
    Depth First Traversals:
    Inorder (Left, Root, Right) : 4 2 5 1 3
    Preorder (Root, Left, Right) : 1 2 4 5 3
    Postorder (Left, Right, Root) : 4 5 2 3 1
                    </code>
                </pre>
                        </div>
                        <div>
                            <a href="https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/">Tree Traversals (Inorder, Preorder and Postorder)</a>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. InOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class InOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        run(node.left);
        System.out.print(node.val);
        run(node.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. PreOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class PreOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        System.out.print(node.val);
        run(node.left);
        run(node.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. PostOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class PostOrder {
    void run(TreeNode node) {
        if (node == null) {
            return;
        }
        run(node.left);
        run(node.right);
        System.out.print(node.val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. LevelOrder</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class LevelOrder {
    List[List[Integer]] levelOrder(TreeNode root) {
        List[List[Integer]] list = new ArrayList[]();
        return addlevel(root, 0, list);
    }

    private List[List[Integer]] addlevel(
    TreeNode root, int level, List[List[Integer]] list) {
        if (root == null) return list;
        if (list.size() == level) {
            list.add(new ArrayList[]());
        }
        list.get(level).add(root.val);
        addlevel(root.left, level + 1, list);
        addlevel(root.right, level + 1, list);
        return list;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
            <!-- Binary Tree. Traverse A Tree. Finish.-->
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Maximum Depth</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Symmetric</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isMirror(root.left, root.right);
    }

    boolean isMirror(TreeNode l, TreeNode r) {
        if (l == null && r == null) return true;
        if (l == null || r == null) return false;
        return (l.val == r.val) && isMirror(l.right, r.left) && isMirror(l.left, r.right);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Path Sum</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        return calc(root, sum);
    }

    boolean calc(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (root.val == sum && root.left == null && root.right == null) {
            return true;
        }
        return calc(root.left, sum - root.val) || calc(root.right, sum - root.val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Serialize and Deserialize</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) return "#";
        return root.val + "," + serialize(root.left) + "," + serialize(root.right);
    }

    public TreeNode deserialize(String data) {
        Queue[String] queue = new LinkedList[](Arrays.asList(data.split(",")));
        return helper(queue);
    }

    private TreeNode helper(Queue[String] queue) {
        String s = queue.poll();
        if (s.equals("#")) return null;
        TreeNode root = new TreeNode(Integer.valueOf(s));
        root.left = helper(queue);
        root.right = helper(queue);
        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Construct Binary Tree from Inorder and Postorder Traversal</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    int p;
    Map[Integer, Integer] map = new HashMap[]();
    public TreeNode buildTree(int[] in, int[] post) {
        if(in == null || in.length == 0) return null;
        for(int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        p = post.length-1;
        return build(in, post, 0, post.length-1);
    }

    TreeNode build(int[] in, int[] post, int start, int end) {
        if(end < start) {
            p++;
            return null;
        }
        int rIdx = map.get(post[p]);
        TreeNode root = new TreeNode(post[p]);
        if(start == end) return root;
        p--;
        root.right = build(in, post, rIdx+1, end);
        p--;
        root.left = build(in, post, start, rIdx-1);
        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Construct Binary Tree from Preorder and Inorder Traversal</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
         int N = preorder.length;
        if(N==0) return null;
        TreeNode root= new TreeNode(preorder[0]);
        if(N==1) return root;

        int L = 0;
        for(int i=0;i< N;++i){
            if(inorder[i]==preorder[0])
                L = i;
        }
        root.left = buildTree(Arrays.copyOfRange(preorder, 1, L+1),
                                         Arrays.copyOfRange(inorder, 0, L));
        root.right = buildTree(Arrays.copyOfRange(preorder, L+1, N), Arrays.copyOfRange(inorder, L+1, N));
        return root;

    }

}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Validate Binary Search Tree</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public boolean helper(TreeNode node, Integer lower, Integer upper) {
        if (node == null) return true;

        int val = node.val;
        if (lower != null && val <= lower) return false;
        if (upper != null && val >= upper) return false;

        if (!helper(node.right, val, upper)) return false;
        if (!helper(node.left, lower, val)) return false;
        return true;
    }

    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. BSTIterator</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class BSTIterator {

    ArrayList[Integer] nodesSorted;
    int index;

    public BSTIterator(TreeNode root) {

        // Array containing all the nodes in the sorted order
        this.nodesSorted = new ArrayList[Integer]();

        // Pointer to the next smallest element in the BST
        this.index = -1;

        // Call to flatten the input binary search tree
        this._inorder(root);
    }

    private void _inorder(TreeNode root) {

        if (root == null) {
            return;
        }

        this._inorder(root.left);
        this.nodesSorted.add(root.val);
        this._inorder(root.right);
    }

    /**
     * @return the next smallest number
     */
    public int next() {
        return this.nodesSorted.get(++this.index);
    }

    /**
     * @return whether we have a next smallest number
     */
    public boolean hasNext() {
        return this.index + 1 < this.nodesSorted.size();
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. Search in a Binary Search Tree</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root == null) return null;
        if(root.val == val)
            return root;
        if(val < root.val)
            return searchBST(root.left, val);
        else
            return searchBST(root.right, val);
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td>
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>Binary Tree. Insert into a Binary Search Tree</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            root = new TreeNode(val);
            return root;
        }

        if (root.left == null && root.right == null) {
            if (root.val <= val)
                root.right = new TreeNode(val);
            else
                root.left = new TreeNode(val);

            return root;
        }

        if (root.val <= val)
            root.right = insertIntoBST(root.right, val);

        else
            root.left = insertIntoBST(root.left, val);

        return root;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                    <td>
                        <div>Binary Tree. </div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null)
            return root;

        if (key < root.val)
            root.left = deleteNode(root.left, key);

        else if (key > root.val)
            root.right = deleteNode(root.right, key);

        else {
            if (root.left == null)
                return root.right;

            else if (root.right == null)
                return root.left;

            root.val = minValue(root.right);
            root.right = deleteNode(root.right, root.val);
        }

        return root;
    }

    private int minValue(TreeNode root) {
        int minv = root.val;

        while (root.left != null) {
            minv = root.left.val;
            root = root.left;
        }

        return minv;
    }
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <!-- Binary Tree. Finish.-->
    <!-- Breadth-first Search & Depth-First Search.-->
    <tr>
        <td>
            <div>Breadth-first Search & Depth-First Search</div>
        </td>
    <tr>
        <td>
            <!-- Binary Tree. Traverse A Tree.-->
            <table cellspacing="0" cellpadding="0" width="100%" height="100%" border="1">
                <tr>
                    <td>
                        <div>bfs</div>
                    </td>
                    <td>
                        <div>
	<pre>
	<code>
static int bfs(Node root, Node target) {
    final LinkedList[Node] queue = new LinkedList[]();
    queue.add(root);
    int step = 0;
    while (!queue.isEmpty()) {
        step = step + 1;
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            final Node current = queue.remove();
            if (target.data == current.data) return step;
            for (Node next : current.getNodes()) {
                queue.add(next);
            }
        }
    }
    return -1;
}
	</code>
	</pre>
                        </div>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <!-- Breadth-first Search & Depth-First Search. Finish.-->
</table>
</body>
</html>